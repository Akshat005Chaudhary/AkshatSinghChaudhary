[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.13.6","content-config-digest","f756207bb1b45114","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://blahg.netlify.app/\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"material-theme-darker\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false}}","posts",["Map",11,12,36,37,61,62],"weylus-ipad-drawing-pad",{"id":11,"data":13,"body":19,"filePath":20,"digest":21,"rendered":22},{"title":14,"slug":11,"description":15,"added":16,"tags":17},"Weylus","How to make your Ipad a drawing pad for you PC",["Date","2025-10-05T02:58:25.226Z"],[18],"technical","### Starting with weylus\n\n* [https://github.com/H-M-H/Weylus](https://github.com/H-M-H/Weylus)\n* Grab latest release for your OS\n* Install it through `sudo apt install ./Weylus_0.11.4_amd64.deb`\n* Enable uinput for features like pressure sensitivity and multitouch.\n* Now your app is ready\n* To allow screen share install necessary packages for wayland,gnome\n* Remember that screen share only works from ubuntu to ipad not the other way\n* To use the app:\n  * Open weylus app\n  * click start\n  * open the given url in ipad browser\n  * make sure ipad and pc are in the same network\n  * choose to share or not share screen\n  * for sharing screen choose capture pipewire\n  * for drawing on microsoft whiteboard use **monitor:eDP-1** and disable video for a white space\n* With this application you can:\n  * share screen of laptop into ipad (screen mirroring)\n  * use ipad as a drawing board for microsoft whiteboard","posts/weylus-ipad-drawing-pad.md","40e86c709442cb26",{"html":23,"metadata":24},"\u003Ch3 id=\"starting-with-weylus\">Starting with weylus\u003C/h3>\n\u003Cul>\n\u003Cli>\u003Ca href=\"https://github.com/H-M-H/Weylus\">https://github.com/H-M-H/Weylus\u003C/a>\u003C/li>\n\u003Cli>Grab latest release for your OS\u003C/li>\n\u003Cli>Install it through \u003Ccode>sudo apt install ./Weylus_0.11.4_amd64.deb\u003C/code>\u003C/li>\n\u003Cli>Enable uinput for features like pressure sensitivity and multitouch.\u003C/li>\n\u003Cli>Now your app is ready\u003C/li>\n\u003Cli>To allow screen share install necessary packages for wayland,gnome\u003C/li>\n\u003Cli>Remember that screen share only works from ubuntu to ipad not the other way\u003C/li>\n\u003Cli>To use the app:\n\u003Cul>\n\u003Cli>Open weylus app\u003C/li>\n\u003Cli>click start\u003C/li>\n\u003Cli>open the given url in ipad browser\u003C/li>\n\u003Cli>make sure ipad and pc are in the same network\u003C/li>\n\u003Cli>choose to share or not share screen\u003C/li>\n\u003Cli>for sharing screen choose capture pipewire\u003C/li>\n\u003Cli>for drawing on microsoft whiteboard use \u003Cstrong>monitor:eDP-1\u003C/strong> and disable video for a white space\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>With this application you can:\n\u003Cul>\n\u003Cli>share screen of laptop into ipad (screen mirroring)\u003C/li>\n\u003Cli>use ipad as a drawing board for microsoft whiteboard\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>",{"headings":25,"localImagePaths":30,"remoteImagePaths":31,"frontmatter":32,"imagePaths":35},[26],{"depth":27,"slug":28,"text":29},3,"starting-with-weylus","Starting with weylus",[],[],{"title":14,"slug":11,"description":15,"tags":33,"added":34},[18],["Date","2025-10-05T02:58:25.226Z"],[],"amazon-technical-qs",{"id":36,"data":38,"body":45,"filePath":46,"digest":47,"rendered":48},{"title":39,"slug":36,"description":40,"added":41,"tags":42},"80+ Amazon Technical Questions","These are frequently asked questions in Amazon's technical rounds and interviews",["Date","2025-10-05T03:14:59.372Z"],[18,43,44],"learning","placements","### 80+ Amazon Technical Questions:\n\n> Note: Amazon might ask questions which are java based, but you try to answer in C++ confidently while focusing on the mapping between them as well.\n\n1. Do you have any technical certifications?\n2. What is the extent of your technical expertise?\n3. What do you do to improve your technical skills?\n4. Give an example of how you apply your technical knowledge in a practical way?\n5. What was the recent technical project you worked on? What were your key responsibilities?\n6. What is the production deployment process you follow?\n7. What do you like most about the IT industry? What do you enjoy the least about it?\n8. Why is a solution design document important?\n9. Whenever you solve a problem, who do you keep in mind? The end-user, the business, or yourself, and why?\n10. How many programming languages do you know?\n11. Why you prefer the language you prefer (I prefer C++ and JS)\n12. What is the use of printf() and scanf() functions?\n13. What is the static variable? What is its use? Difference between global, constant and static declaration of a variable.\n14. What is the difference between call by value and call by reference in C?\n15. What is Recursion in C?\n16. What is a pointer in C? What are its uses?\n17. What is a NULL pointer and far pointer?\n18. What is a dangling pointer? How is it overcome?\n19. What is a command line argument?\n20. Can we compile a program without the main() function?\n21. What is an object and class?\n22. Compilation process in Java\n23. Compilation process in C/C++\n24. Interpretation in Python\n25. What do you mean by JVM, JDK and JRE?\n26. How can you restrict inheritance in C++? What is final keyword?\n27. Static methods in C++\n28. What is enumeration?\n29. What is the use of â€˜thisâ€™ keyword in C++?\n30. Why is Java/Python platform independent while C/C++ is not?\n31. What are access modifiers in C++?\n32. What is private constructor in C++?\n33. Access Modifiers in Java/C++\n34. Method overriding in C++/Java\n35. Compiled vs Interpreter languages\n36. What are lists and tuples in Python?\n37. What is pass in Python?\n38. What is self in Python?\n39. Slicing and use of break in Python.\n40. Use of swapcase() in Python.\n41. What is the Python decorator?\n42. What is the difference between Python Arrays and lists?\n43. What is DBMS?\n44. What are tables, fields and record?\n45. What is Foreign Key?\n46. Delete vs Truncate vs Drop?\n47. What is a constraint?\n48. What is ACID property in a database?\n49. What is SQL?\n50. What is a unique key?\n51. What is a relationship and what are they?\n52. What is a query?\n53. What is Machine Learning?\n54. What is Supervised, Unsupervised and Semi-Supervised learning?\n55. What are training set and test set in Machine Learning and why are they important?\n56. Explain the stages of building a Machine Learning model.\n57. How does IoT work?\n58. What is Natural Language Processing?\n59. What is IIOT?\n60. What is Deep Learning?\n61. What is Arduino?\n62. What is Neural Network?\n63. What do you mean by Open-source Hardware?\n64. What is Raspberry Pi?\n65. How is Raspberry Pi used in IoT?\n66. List any two real-life applications of Natural language processing.\n67. What is Ethical Hacking?\n68. What is the difference between IP and MAC address?\n69. Explain LAN\n70. What is VPN?\n71. What are Private and Special IP addresses?\n72. What is DNS?\n73. What is the main purpose of an OS? What are the different types of OS?\n74. What is GUI?\n75. What do you mean by RTOS?\n76. Name some of the most famous OS.\n77. What is IPC?\n78. What is the working of the stack while calling a function?\n79. What are the Semaphores?\n80. Implement queues using linked lists.\n81. Implement a program to Search In A Binary Search Tree.\n82. What is Normalization?\n83. How does instance differ from schema?\n84. Give a program on Breadth-First Search (BFS).\n85. Calculate the diameter of the Binary Search Tree.\n86. What are entry controlled and exit controlled loops?\n87. Why is code optimization important?\n88. Write a code for heap sort.\n89. What is Thrashing in OS?\n90. Write a code to Delete the nth node in Linked List.\n91. What is the use of mutex?\n92. What is the difference between standard modules and class modules?\n93. Write a program for Postfix to Prefix Conversion.","posts/amazon-technical-qs.md","71201cced9fc6948",{"html":49,"metadata":50},"\u003Ch3 id=\"80-amazon-technical-questions\">80+ Amazon Technical Questions:\u003C/h3>\n\u003Cblockquote>\n\u003Cp>Note: Amazon might ask questions which are java based, but you try to answer in C++ confidently while focusing on the mapping between them as well.\u003C/p>\n\u003C/blockquote>\n\u003Col>\n\u003Cli>Do you have any technical certifications?\u003C/li>\n\u003Cli>What is the extent of your technical expertise?\u003C/li>\n\u003Cli>What do you do to improve your technical skills?\u003C/li>\n\u003Cli>Give an example of how you apply your technical knowledge in a practical way?\u003C/li>\n\u003Cli>What was the recent technical project you worked on? What were your key responsibilities?\u003C/li>\n\u003Cli>What is the production deployment process you follow?\u003C/li>\n\u003Cli>What do you like most about the IT industry? What do you enjoy the least about it?\u003C/li>\n\u003Cli>Why is a solution design document important?\u003C/li>\n\u003Cli>Whenever you solve a problem, who do you keep in mind? The end-user, the business, or yourself, and why?\u003C/li>\n\u003Cli>How many programming languages do you know?\u003C/li>\n\u003Cli>Why you prefer the language you prefer (I prefer C++ and JS)\u003C/li>\n\u003Cli>What is the use of printf() and scanf() functions?\u003C/li>\n\u003Cli>What is the static variable? What is its use? Difference between global, constant and static declaration of a variable.\u003C/li>\n\u003Cli>What is the difference between call by value and call by reference in C?\u003C/li>\n\u003Cli>What is Recursion in C?\u003C/li>\n\u003Cli>What is a pointer in C? What are its uses?\u003C/li>\n\u003Cli>What is a NULL pointer and far pointer?\u003C/li>\n\u003Cli>What is a dangling pointer? How is it overcome?\u003C/li>\n\u003Cli>What is a command line argument?\u003C/li>\n\u003Cli>Can we compile a program without the main() function?\u003C/li>\n\u003Cli>What is an object and class?\u003C/li>\n\u003Cli>Compilation process in Java\u003C/li>\n\u003Cli>Compilation process in C/C++\u003C/li>\n\u003Cli>Interpretation in Python\u003C/li>\n\u003Cli>What do you mean by JVM, JDK and JRE?\u003C/li>\n\u003Cli>How can you restrict inheritance in C++? What is final keyword?\u003C/li>\n\u003Cli>Static methods in C++\u003C/li>\n\u003Cli>What is enumeration?\u003C/li>\n\u003Cli>What is the use of â€˜thisâ€™ keyword in C++?\u003C/li>\n\u003Cli>Why is Java/Python platform independent while C/C++ is not?\u003C/li>\n\u003Cli>What are access modifiers in C++?\u003C/li>\n\u003Cli>What is private constructor in C++?\u003C/li>\n\u003Cli>Access Modifiers in Java/C++\u003C/li>\n\u003Cli>Method overriding in C++/Java\u003C/li>\n\u003Cli>Compiled vs Interpreter languages\u003C/li>\n\u003Cli>What are lists and tuples in Python?\u003C/li>\n\u003Cli>What is pass in Python?\u003C/li>\n\u003Cli>What is self in Python?\u003C/li>\n\u003Cli>Slicing and use of break in Python.\u003C/li>\n\u003Cli>Use of swapcase() in Python.\u003C/li>\n\u003Cli>What is the Python decorator?\u003C/li>\n\u003Cli>What is the difference between Python Arrays and lists?\u003C/li>\n\u003Cli>What is DBMS?\u003C/li>\n\u003Cli>What are tables, fields and record?\u003C/li>\n\u003Cli>What is Foreign Key?\u003C/li>\n\u003Cli>Delete vs Truncate vs Drop?\u003C/li>\n\u003Cli>What is a constraint?\u003C/li>\n\u003Cli>What is ACID property in a database?\u003C/li>\n\u003Cli>What is SQL?\u003C/li>\n\u003Cli>What is a unique key?\u003C/li>\n\u003Cli>What is a relationship and what are they?\u003C/li>\n\u003Cli>What is a query?\u003C/li>\n\u003Cli>What is Machine Learning?\u003C/li>\n\u003Cli>What is Supervised, Unsupervised and Semi-Supervised learning?\u003C/li>\n\u003Cli>What are training set and test set in Machine Learning and why are they important?\u003C/li>\n\u003Cli>Explain the stages of building a Machine Learning model.\u003C/li>\n\u003Cli>How does IoT work?\u003C/li>\n\u003Cli>What is Natural Language Processing?\u003C/li>\n\u003Cli>What is IIOT?\u003C/li>\n\u003Cli>What is Deep Learning?\u003C/li>\n\u003Cli>What is Arduino?\u003C/li>\n\u003Cli>What is Neural Network?\u003C/li>\n\u003Cli>What do you mean by Open-source Hardware?\u003C/li>\n\u003Cli>What is Raspberry Pi?\u003C/li>\n\u003Cli>How is Raspberry Pi used in IoT?\u003C/li>\n\u003Cli>List any two real-life applications of Natural language processing.\u003C/li>\n\u003Cli>What is Ethical Hacking?\u003C/li>\n\u003Cli>What is the difference between IP and MAC address?\u003C/li>\n\u003Cli>Explain LAN\u003C/li>\n\u003Cli>What is VPN?\u003C/li>\n\u003Cli>What are Private and Special IP addresses?\u003C/li>\n\u003Cli>What is DNS?\u003C/li>\n\u003Cli>What is the main purpose of an OS? What are the different types of OS?\u003C/li>\n\u003Cli>What is GUI?\u003C/li>\n\u003Cli>What do you mean by RTOS?\u003C/li>\n\u003Cli>Name some of the most famous OS.\u003C/li>\n\u003Cli>What is IPC?\u003C/li>\n\u003Cli>What is the working of the stack while calling a function?\u003C/li>\n\u003Cli>What are the Semaphores?\u003C/li>\n\u003Cli>Implement queues using linked lists.\u003C/li>\n\u003Cli>Implement a program to Search In A Binary Search Tree.\u003C/li>\n\u003Cli>What is Normalization?\u003C/li>\n\u003Cli>How does instance differ from schema?\u003C/li>\n\u003Cli>Give a program on Breadth-First Search (BFS).\u003C/li>\n\u003Cli>Calculate the diameter of the Binary Search Tree.\u003C/li>\n\u003Cli>What are entry controlled and exit controlled loops?\u003C/li>\n\u003Cli>Why is code optimization important?\u003C/li>\n\u003Cli>Write a code for heap sort.\u003C/li>\n\u003Cli>What is Thrashing in OS?\u003C/li>\n\u003Cli>Write a code to Delete the nth node in Linked List.\u003C/li>\n\u003Cli>What is the use of mutex?\u003C/li>\n\u003Cli>What is the difference between standard modules and class modules?\u003C/li>\n\u003Cli>Write a program for Postfix to Prefix Conversion.\u003C/li>\n\u003C/ol>",{"headings":51,"localImagePaths":55,"remoteImagePaths":56,"frontmatter":57,"imagePaths":60},[52],{"depth":27,"slug":53,"text":54},"80-amazon-technical-questions","80+ Amazon Technical Questions:",[],[],{"title":39,"slug":36,"description":40,"tags":58,"added":59},[18,43,44],["Date","2025-10-05T03:14:59.372Z"],[],"graphs-that-stick-part-1-cpp-reference-collection",{"id":61,"data":63,"body":71,"filePath":72,"digest":73,"rendered":74},{"title":64,"slug":61,"description":65,"added":66,"tags":67},"Graphs That Stick (Part 1): My C++ Reference Collection","This post is the first part of the Graphs That Stick series, built to give you reusable, memory-friendly implementations that actually stay in your head. Perfect for quick lookup during contests, interviews, or while debugging your own graph solutions.",["Date","2025-10-18T07:37:17.295Z"],[68,69,70],"DSA","Technical","Interview","````markdown\n**1. Graph Representation by Adjacency Matrix:**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\nusing namespace std;\n\nvoid addEdge(vector\u003Cvector\u003Cint>> &adjMatrix, int u, int v) {\n    adjMatrix[u][v] = 1;\n    adjMatrix[v][u] = 1;\n}\n\nvoid printMatrix(const vector\u003Cvector\u003Cint>> &adjMatrix) {\n    for (const auto &row : adjMatrix) {\n        for (int val : row) {\n            cout \u003C\u003C val \u003C\u003C \" \";\n        }\n        cout \u003C\u003C endl;\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector\u003Cvector\u003Cint>> adjMatrix(V, vector\u003Cint>(V, 0));\n    for (int i = 0; i \u003C E; i++) {\n        int u, v;\n        cin >> u >> v;\n        addEdge(adjMatrix, u, v);\n    }\n    printMatrix(adjMatrix);\n    return 0;\n}\n```\n\n---\n\n**2. Graph Representation by Adjacency List:**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\nusing namespace std;\n\nvoid addEdge(vector\u003Cvector\u003Cint>> &adjList, int u, int v) {\n    adjList[u].push_back(v);\n    adjList[v].push_back(u);\n}\n\nvoid printGraph(const vector\u003Cvector\u003Cint>> &adjList) {\n    for (int i = 0; i \u003C adjList.size(); i++) {\n        cout \u003C\u003C \"Vertex \" \u003C\u003C i \u003C\u003C \": \";\n        for (int neighbor : adjList[i]) {\n            cout \u003C\u003C neighbor \u003C\u003C \" \";\n        }\n        cout \u003C\u003C endl;\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector\u003Cvector\u003Cint>> adjList(V);\n    for (int i = 0; i \u003C E; i++) {\n        int u, v;\n        cin >> u >> v;\n        addEdge(adjList, u, v);\n    }\n    printGraph(adjList);\n    return 0;\n}\n```\n\n---\n\n**3. BFS:**\n\n```\n#include \u003Ciostream>\n#include \u003Cqueue>\n#include \u003Cvector>\nusing namespace std;\n\nvoid breadthFirstSearch(vector\u003Cvector\u003Cint>>& adjMatrix, int vertices, int startVertex) {\n    vector\u003Cbool> visited(vertices, false);\n    queue\u003Cint> q;\n\n    q.push(startVertex);\n    visited[startVertex] = true;\n\n    while (!q.empty()) {\n        int currentVertex = q.front();\n        q.pop();\n        cout \u003C\u003C currentVertex \u003C\u003C \" \";\n\n        for (int i = 0; i \u003C vertices; i++) {\n            if (adjMatrix[currentVertex][i] == 1 && !visited[i]) {\n                q.push(i);\n                visited[i] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int vertices, startVertex;\n\n    cout \u003C\u003C \"Enter the number of vertices: \";\n    cin >> vertices;\n\n    vector\u003Cvector\u003Cint>> adjMatrix(vertices, vector\u003Cint>(vertices, 0));\n\n    cout \u003C\u003C \"Enter the adjacency matrix:\\n\";\n    for (int i = 0; i \u003C vertices; i++) {\n        for (int j = 0; j \u003C vertices; j++) {\n            cin >> adjMatrix[i][j];\n        }\n    }\n\n    cout \u003C\u003C \"Enter the starting vertex for BFS: \";\n    cin >> startVertex;\n\n    cout \u003C\u003C \"BFS Traversal: \";\n    breadthFirstSearch(adjMatrix, vertices, startVertex);\n    cout \u003C\u003C \"\\n\";\n\n    return 0;\n}\n```\n\n- Time Complexity: O(V^2)\n\n---\n\n**4. DFS:**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\nusing namespace std;\n\nvector\u003Cvector\u003Cint>> adjMatrix;\nvector\u003Cbool> visited;\n\nvoid initializeGraph(int vertices) {\n    adjMatrix.assign(vertices, vector\u003Cint>(vertices, 0));\n    visited.assign(vertices, false);\n}\n\nvoid addEdge(int src, int dest) {\n    adjMatrix[src][dest] = 1;\n    adjMatrix[dest][src] = 1; // For undirected graph\n}\n\nvoid dfs(int vertex, int vertices) {\n    visited[vertex] = true;\n    cout \u003C\u003C vertex \u003C\u003C \" \";\n\n    for (int i = 0; i \u003C vertices; i++) {\n        if (adjMatrix[vertex][i] && !visited[i]) {\n            dfs(i, vertices);\n        }\n    }\n}\n\nint main() {\n    int vertices, edges, src, dest;\n\n    cout \u003C\u003C \"Enter the number of vertices: \";\n    cin >> vertices;\n\n    initializeGraph(vertices);\n\n    cout \u003C\u003C \"Enter the number of edges: \";\n    cin >> edges;\n\n    cout \u003C\u003C \"Enter edges (source destination):\\n\";\n    for (int i = 0; i \u003C edges; i++) {\n        cin >> src >> dest;\n        addEdge(src, dest);\n    }\n\n    int startVertex;\n    cout \u003C\u003C \"Enter the starting vertex for DFS: \";\n    cin >> startVertex;\n\n    cout \u003C\u003C \"DFS Traversal: \";\n    dfs(startVertex, vertices);\n    cout \u003C\u003C \"\\n\";\n\n    return 0;\n}\n```\n\n- Time Complexity: O(V+E)\n\n---\n\n**5. Dijkstra's Algorithm (Shortest Path):**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n#include \u003Cclimits>\n\nusing namespace std;\n\n// Define a pair to store (distance, vertex)\ntypedef pair\u003Cint, int> pii;\n\n// Dijkstra's Algorithm Function\nvoid dijkstra(int source, int V, vector\u003Cvector\u003Cpii>>& adj) {\n    // Distance vector initialized to infinity\n    vector\u003Cint> dist(V, INT_MAX);\n\n    // Min-Heap: (distance, vertex)\n    priority_queue\u003Cpii, vector\u003Cpii>, greater\u003Cpii>> pq;\n\n    // Initialize the source distance to 0\n    dist[source] = 0;\n    pq.push({0, source});\n\n    while (!pq.empty()) {\n        // Extract the vertex with the smallest distance\n        int currentDist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        // Traverse all adjacent vertices of 'u'\n        for (auto& edge : adj[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n\n            // Relaxation: Check if a shorter path exists\n            if (currentDist + weight \u003C dist[v]) {\n                dist[v] = currentDist + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    // Print the shortest distances\n    cout \u003C\u003C \"Vertex\\tDistance from Source\\n\";\n    for (int i = 0; i \u003C V; ++i) {\n        cout \u003C\u003C i \u003C\u003C \"\\t\" \u003C\u003C dist[i] \u003C\u003C \"\\n\";\n    }\n}\n\nint main() {\n    int V = 5; // Number of vertices\n    vector\u003Cvector\u003Cpii>> adj(V);\n\n    // Add edges (u, v, weight)\n    adj[0].push_back({1, 2});\n    adj[0].push_back({3, 1});\n    adj[1].push_back({2, 3});\n    adj[3].push_back({4, 6});\n    adj[4].push_back({2, 1});\n\n    int source = 0; // Source vertex\n    dijkstra(source, V, adj);\n\n    return 0;\n}\n```\n\n- Time Complexity: O((V+E)logV)\n\n---\n\n**6. Bellman Ford Algorithm (Shortest Path):**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cclimits>\n\nusing namespace std;\n\n// Bellman-Ford Algorithm Function\nbool bellmanFord(int source, int V, int E, vector\u003Cvector\u003Cint>>& edges) {\n    // Distance vector initialized to infinity\n    vector\u003Cint> dist(V, INT_MAX);\n\n    // Initialize the source distance to 0\n    dist[source] = 0;\n\n    // Relax all edges (V - 1) times\n    for (int i = 0; i \u003C V - 1; ++i) {\n        for (int j = 0; j \u003C E; ++j) {\n            int u = edges[j][0];\n            int v = edges[j][1];\n            int weight = edges[j][2];\n\n            // Relaxation: Check if a shorter path exists\n            if (dist[u] != INT_MAX && dist[u] + weight \u003C dist[v]) {\n                dist[v] = dist[u] + weight;\n            }\n        }\n    }\n\n    // Check for negative weight cycles\n    for (int j = 0; j \u003C E; ++j) {\n        int u = edges[j][0];\n        int v = edges[j][1];\n        int weight = edges[j][2];\n\n        if (dist[u] != INT_MAX && dist[u] + weight \u003C dist[v]) {\n            cout \u003C\u003C \"Graph contains a negative weight cycle.\\n\";\n            return false;\n        }\n    }\n\n    // Print the shortest distances\n    cout \u003C\u003C \"Vertex\\tDistance from Source\\n\";\n    for (int i = 0; i \u003C V; ++i) {\n        cout \u003C\u003C i \u003C\u003C \"\\t\" \u003C\u003C dist[i] \u003C\u003C \"\\n\";\n    }\n\n    return true;\n}\n\nint main() {\n    int V = 5; // Number of vertices\n    int E = 8; // Number of edges\n\n    // Edges: {source, destination, weight}\n    vector\u003Cvector\u003Cint>> edges = {\n        {0, 1, -1},\n        {0, 2, 4},\n        {1, 2, 3},\n        {1, 3, 2},\n        {1, 4, 2},\n        {3, 2, 5},\n        {3, 1, 1},\n        {4, 3, -3}\n    };\n\n    int source = 0; // Source vertex\n    if (!bellmanFord(source, V, E, edges)) {\n        cout \u003C\u003C \"Shortest path computation failed due to a negative weight cycle.\\n\";\n    }\n\n    return 0;\n}\n```\n\n- Time Complexity: O(V\\*E)\n\n---\n\n**7. Floyd-Warshall Algorithm (Shortest Path):**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cclimits>\n\nusing namespace std;\n\n#define INF INT_MAX\n\n// Floyd-Warshall Algorithm Function\nvoid floydWarshall(int V, vector\u003Cvector\u003Cint>>& graph) {\n// Create a distance matrix initialized to the graph's adjacency matrix\nvector\u003Cvector\u003Cint>> dist = graph;\n\n    // Iterate through all vertices as intermediate points\n    for (int k = 0; k \u003C V; ++k) {\n        for (int i = 0; i \u003C V; ++i) {\n            for (int j = 0; j \u003C V; ++j) {\n                // Skip if no path exists through the intermediate vertex\n                if (dist[i][k] == INF || dist[k][j] == INF)\n                    continue;\n\n                // Update the shortest distance\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n\n    // Check for negative weight cycles\n    for (int i = 0; i \u003C V; ++i) {\n        if (dist[i][i] \u003C 0) {\n            cout \u003C\u003C \"Graph contains a negative weight cycle.\\n\";\n            return;\n        }\n    }\n\n    // Print the shortest distances\n    cout \u003C\u003C \"Shortest distances between every pair of vertices:\\n\";\n    for (int i = 0; i \u003C V; ++i) {\n        for (int j = 0; j \u003C V; ++j) {\n            if (dist[i][j] == INF)\n                cout \u003C\u003C \"INF \";\n            else\n                cout \u003C\u003C dist[i][j] \u003C\u003C \" \";\n        }\n        cout \u003C\u003C \"\\n\";\n    }\n\n}\n\nint main() {\nint V = 4; // Number of vertices\n\n    // Adjacency matrix representation of the graph\n    vector\u003Cvector\u003Cint>> graph = {\n        {0, 3, INF, 5},\n        {2, 0, INF, 4},\n        {INF, 1, 0, INF},\n        {INF, INF, 2, 0}\n    };\n\n    floydWarshall(V, graph);\n\n    return 0;\n\n}\n```\n\nTime Complexity: O(V^3)\n\n---\n\n**8. Prim's Algorithm (MST):**\n\n```\n#include \u003Ciostream>\n#include \u003Cvector>\n#include \u003Cqueue>\n#include \u003Cclimits>\n\nusing namespace std;\n\n// A utility function to print the MST\nvoid printMST(const vector\u003Cint>& parent, const vector\u003Cvector\u003Cint>>& graph) {\ncout \u003C\u003C \"Edge\\tWeight\\n\";\nfor (int i = 1; i \u003C graph.size(); ++i) {\ncout \u003C\u003C parent[i] \u003C\u003C \" - \" \u003C\u003C i \u003C\u003C \"\\t\" \u003C\u003C graph[i]parent[i]] \u003C\u003C \"\\n\";\n}\n}\n\n// Prim's Algorithm function\nvoid primMST(int V, vector\u003Cvector\u003Cint>>& graph) {\n// Priority queue to pick the minimum weight edge\npriority_queue\u003Cpair\u003Cint, int>, vector\u003Cpair\u003Cint, int>>, greater\u003Cpair\u003Cint, int>>> pq;\n\n    vector\u003Cint> key(V, INT_MAX);   // Stores the minimum weight for each vertex\n    vector\u003Cbool> inMST(V, false); // Keeps track of vertices included in MST\n    vector\u003Cint> parent(V, -1);    // Stores the MST structure\n\n    // Start with the first vertex (arbitrary choice)\n    key[0] = 0;\n    pq.push({0, 0}); // {weight, vertex}\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n\n        // Include vertex `u` in MST\n        inMST[u] = true;\n\n        // Explore neighbors of `u`\n        for (int v = 0; v \u003C V; ++v) {\n            // If `v` is not in MST and there's an edge `u-v` with smaller weight\n            if (graph[u][v] && !inMST[v] && graph[u][v] \u003C key[v]) {\n                key[v] = graph[u][v];\n                pq.push({key[v], v});\n                parent[v] = u;\n            }\n        }\n    }\n\n    // Print the MST\n    printMST(parent, graph);\n\n}\n\nint main() {\nint V = 5; // Number of vertices\n\n    // Adjacency matrix representation of the graph\n    vector\u003Cvector\u003Cint>> graph = {\n        {0, 2, 0, 6, 0},\n        {2, 0, 3, 8, 5},\n        {0, 3, 0, 0, 7},\n        {6, 8, 0, 0, 9},\n        {0, 5, 7, 9, 0}\n    };\n\n    primMST(V, graph);\n\n    return 0;\n\n}\n```\n\nTime Complexity: O((V+E)logV)\n\n---\n\n**9. Disjoint Set Data Structure (Union-Find):**\n\n> Disjoint Set data structure also known as Union-Find data structure has 2 main operations - Union by Rank/Size and Find operation\n\n> 1. Union by Rank/Size is used to join the smaller set to the larger set\n> 2. Find(x) operation is used to find the parent root node of the x node, at starting each set comprises of a single element who is the parent of itself\n\n```\n#include \u003Cbits/stdc++.h>\nusing namespace std;\n\nclass DisjointSet {\n    vector\u003Cint> parent, size;\n    public:\n    DisjointSet(int n) {\n        parent.resize(n+1);\n        size.resize(n+1, 1);\n        for(int i = 0; i \u003C= n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int node) {\n        if(node == parent[node]) {\n            return node;\n        }\n        return parent[node] = find(parent[node]);\n    }\n\n    void unionBySize(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if(rootU == rootV) {\n            return;\n        }\n        if(size[rootU] \u003C size[rootV]) {\n            parent[rootU] = rootV;\n            size[rootV] += size[rootU];\n        } else {\n            parent[rootV] = rootU;\n            size[rootU] += size[rootV];\n        }\n    }\n\n};\n\nint main() {\nDisjointSet ds(7);\nds.unionBySize(1, 2);\nds.unionBySize(2, 3);\nds.unionBySize(4, 5);\nds.unionBySize(6, 7);\nds.unionBySize(5, 6);\nif(ds.find(3) == ds.find(7)) {\ncout \u003C\u003C \"Same Component\" \u003C\u003C endl;\n} else {\ncout \u003C\u003C \"Different Component\" \u003C\u003C endl;\n}\nds.unionBySize(3, 7);\nif(ds.find(3) == ds.find(7)) {\ncout \u003C\u003C \"Same Component\" \u003C\u003C endl;\n} else {\ncout \u003C\u003C \"Different Component\" \u003C\u003C endl;\n}\nreturn 0;\n}\n```\n\nTime Complexity: The amortized time complexity for both find and unionBySize is O(Î±(n)), which is nearly constant time for all practical purposes.\n\n---\n\n**10. Kruskal's Algorithm (MST):**\n\n> Algo for Kruskal's:\n\n    1. Sort the graph as per edges in ascending order\n    2. Perform union operation on 2 disjoint sets if they have different parent\n\n```\n#include \u003Cbits/stdc++.h>\nusing namespace std;\n\nbool compareEdges(const vector\u003Cint>& a, const vector\u003Cint>& b) {\nreturn a[2] \u003C b[2];\n}\n\nclass DisjointSet {\nvector\u003Cint> parent, size;\npublic:\nDisjointSet(int n) {\nparent.resize(n+1);\nsize.resize(n+1, 1);\nfor(int i = 0; i \u003C= n; i++) {\nparent[i] = i;\n}\n}\n\n    int findParent(int node) {\n        if(node == parent[node])\n            return node;\n        return parent[node] = findParent(parent[node]);\n    }\n\n    void unionBySize(int u, int v) {\n        int rootU = findParent(u);\n        int rootV = findParent(v);\n        if(rootU != rootV) {\n            if(size[rootU] \u003C size[rootV]) {\n                parent[rootU] = rootV;\n                size[rootV] += size[rootU];\n            } else {\n                parent[rootV] = rootU;\n                size[rootU] += size[rootV];\n            }\n        }\n    }\n\n};\n\nint kruskalMST(int n, vector\u003Cvector\u003Cint>>& edges) {\nsort(edges.begin(), edges.end(), compareEdges);\n\n    DisjointSet ds(n);\n    int mstWeight = 0;\n\n    for(auto& edge : edges) {\n        int u = edge[0];\n        int v = edge[1];\n        int weight = edge[2];\n\n        if(ds.findParent(u) != ds.findParent(v)) {\n            mstWeight += weight;\n            ds.unionBySize(u, v);\n        }\n    }\n\n    return mstWeight;\n\n}\n\nint main() {\nint n = 5; // Number of vertices\nvector\u003Cvector\u003Cint>> edges = {\n{0, 1, 10},\n{0, 2, 6},\n{0, 3, 5},\n{1, 3, 15},\n{2, 3, 4}\n};\n\n    cout \u003C\u003C \"Weight of MST is \" \u003C\u003C kruskalMST(n, edges) \u003C\u003C endl;\n\n    return 0;\n\n}\n```\n\nTime Complexity: O(ElogE+EÎ±(V)). Since ð›¼ ( ð‘‰ ) Î±(V) is very small, this simplifies to ð‘‚ ( ð¸ log â¡ ð¸ ) O(ElogE).\n\n---\n\n\n````","posts/graphs-that-stick-part-1-cpp-reference-collection.md.md","8bbce74a6f12268e",{"html":75,"metadata":76},"\u003Cpre class=\"astro-code material-theme-darker\" style=\"background-color:#212121;color:#EEFFFF; overflow-x: auto;\" tabindex=\"0\" data-language=\"markdown\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">1. Graph Representation by Adjacency Matrix:\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void addEdge(vector&#x3C;vector&#x3C;int>> &#x26;adjMatrix, int u, int v) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjMatrix[u][v] = 1;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjMatrix[v][u] = 1;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void printMatrix(const vector&#x3C;vector&#x3C;int>> &#x26;adjMatrix) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (const auto &#x26;row : adjMatrix) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int val : row) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            cout &#x3C;&#x3C; val &#x3C;&#x3C; \" \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int V, E;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> V >> E;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;int>> adjMatrix(V, vector&#x3C;int>(V, 0));\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; E; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int u, v;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cin >> u >> v;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        addEdge(adjMatrix, u, v);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    printMatrix(adjMatrix);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">2. Graph Representation by Adjacency List:\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void addEdge(vector&#x3C;vector&#x3C;int>> &#x26;adjList, int u, int v) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjList[u].push_back(v);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjList[v].push_back(u);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void printGraph(const vector&#x3C;vector&#x3C;int>> &#x26;adjList) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; adjList.size(); i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; \"Vertex \" &#x3C;&#x3C; i &#x3C;&#x3C; \": \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int neighbor : adjList[i]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            cout &#x3C;&#x3C; neighbor &#x3C;&#x3C; \" \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int V, E;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> V >> E;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;int>> adjList(V);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; E; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int u, v;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cin >> u >> v;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        addEdge(adjList, u, v);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    printGraph(adjList);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">3. BFS:\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;queue>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void breadthFirstSearch(vector&#x3C;vector&#x3C;int>>&#x26; adjMatrix, int vertices, int startVertex) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;bool> visited(vertices, false);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    queue&#x3C;int> q;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    q.push(startVertex);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    visited[startVertex] = true;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    while (!q.empty()) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int currentVertex = q.front();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        q.pop();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; currentVertex &#x3C;&#x3C; \" \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int i = 0; i &#x3C; vertices; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            if (adjMatrix[currentVertex][i] == 1 &#x26;&#x26; !visited[i]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                q.push(i);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                visited[i] = true;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int vertices, startVertex;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter the number of vertices: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> vertices;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;int>> adjMatrix(vertices, vector&#x3C;int>(vertices, 0));\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter the adjacency matrix:\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; vertices; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int j = 0; j &#x3C; vertices; j++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            cin >> adjMatrix[i][j];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter the starting vertex for BFS: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> startVertex;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"BFS Traversal: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    breadthFirstSearch(adjMatrix, vertices, startVertex);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">-\u003C/span>\u003Cspan style=\"color:#EEFFFF\"> Time Complexity: O(V^2)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">4. DFS:\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">vector&#x3C;vector&#x3C;int>> adjMatrix;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">vector&#x3C;bool> visited;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void initializeGraph(int vertices) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjMatrix.assign(vertices, vector&#x3C;int>(vertices, 0));\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    visited.assign(vertices, false);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void addEdge(int src, int dest) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjMatrix[src][dest] = 1;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adjMatrix[dest][src] = 1; // For undirected graph\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void dfs(int vertex, int vertices) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    visited[vertex] = true;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; vertex &#x3C;&#x3C; \" \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; vertices; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if (adjMatrix[vertex][i] &#x26;&#x26; !visited[i]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            dfs(i, vertices);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int vertices, edges, src, dest;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter the number of vertices: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> vertices;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    initializeGraph(vertices);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter the number of edges: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> edges;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter edges (source destination):\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; edges; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cin >> src >> dest;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        addEdge(src, dest);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int startVertex;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Enter the starting vertex for DFS: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cin >> startVertex;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"DFS Traversal: \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    dfs(startVertex, vertices);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">-\u003C/span>\u003Cspan style=\"color:#EEFFFF\"> Time Complexity: O(V+E)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">5. Dijkstra's Algorithm (Shortest Path):\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;queue>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;climits>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Define a pair to store (distance, vertex)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">typedef pair&#x3C;int, int> pii;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Dijkstra's Algorithm Function\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void dijkstra(int source, int V, vector&#x3C;vector&#x3C;pii>>&#x26; adj) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Distance vector initialized to infinity\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;int> dist(V, INT_MAX);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Min-Heap: (distance, vertex)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    priority_queue&#x3C;pii, vector&#x3C;pii>, greater&#x3C;pii>> pq;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Initialize the source distance to 0\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    dist[source] = 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    pq.push({0, source});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    while (!pq.empty()) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        // Extract the vertex with the smallest distance\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int currentDist = pq.top().first;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int u = pq.top().second;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        pq.pop();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        // Traverse all adjacent vertices of 'u'\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (auto&#x26; edge : adj[u]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            int v = edge.first;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            int weight = edge.second;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            // Relaxation: Check if a shorter path exists\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            if (currentDist + weight &#x3C; dist[v]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                dist[v] = currentDist + weight;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                pq.push({dist[v], v});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Print the shortest distances\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Vertex\\tDistance from Source\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; V; ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; i &#x3C;&#x3C; \"\\t\" &#x3C;&#x3C; dist[i] &#x3C;&#x3C; \"\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int V = 5; // Number of vertices\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;pii>> adj(V);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Add edges (u, v, weight)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adj[0].push_back({1, 2});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adj[0].push_back({3, 1});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adj[1].push_back({2, 3});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adj[3].push_back({4, 6});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    adj[4].push_back({2, 1});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int source = 0; // Source vertex\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    dijkstra(source, V, adj);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">-\u003C/span>\u003Cspan style=\"color:#EEFFFF\"> Time Complexity: O((V+E)logV)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">6. Bellman Ford Algorithm (Shortest Path):\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;climits>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Bellman-Ford Algorithm Function\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">bool bellmanFord(int source, int V, int E, vector&#x3C;vector&#x3C;int>>&#x26; edges) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Distance vector initialized to infinity\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;int> dist(V, INT_MAX);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Initialize the source distance to 0\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    dist[source] = 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Relax all edges (V - 1) times\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; V - 1; ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int j = 0; j &#x3C; E; ++j) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            int u = edges[j][0];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            int v = edges[j][1];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            int weight = edges[j][2];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            // Relaxation: Check if a shorter path exists\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            if (dist[u] != INT_MAX &#x26;&#x26; dist[u] + weight &#x3C; dist[v]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                dist[v] = dist[u] + weight;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Check for negative weight cycles\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int j = 0; j &#x3C; E; ++j) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int u = edges[j][0];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int v = edges[j][1];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int weight = edges[j][2];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if (dist[u] != INT_MAX &#x26;&#x26; dist[u] + weight &#x3C; dist[v]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            cout &#x3C;&#x3C; \"Graph contains a negative weight cycle.\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            return false;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Print the shortest distances\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Vertex\\tDistance from Source\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; V; ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; i &#x3C;&#x3C; \"\\t\" &#x3C;&#x3C; dist[i] &#x3C;&#x3C; \"\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return true;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int V = 5; // Number of vertices\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int E = 8; // Number of edges\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Edges: {source, destination, weight}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;int>> edges = {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {0, 1, -1},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {0, 2, 4},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {1, 2, 3},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {1, 3, 2},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {1, 4, 2},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {3, 2, 5},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {3, 1, 1},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {4, 3, -3}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    };\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int source = 0; // Source vertex\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    if (!bellmanFord(source, V, E, edges)) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; \"Shortest path computation failed due to a negative weight cycle.\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">-\u003C/span>\u003Cspan style=\"color:#EEFFFF\"> Time Complexity: O(V\\*E)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">7. Floyd-Warshall Algorithm (Shortest Path):\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;climits>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#define INF INT_MAX\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Floyd-Warshall Algorithm Function\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void floydWarshall(int V, vector&#x3C;vector&#x3C;int>>&#x26; graph) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Create a distance matrix initialized to the graph's adjacency matrix\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">vector&#x3C;vector&#x3C;int>> dist = graph;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Iterate through all vertices as intermediate points\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int k = 0; k &#x3C; V; ++k) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int i = 0; i &#x3C; V; ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            for (int j = 0; j &#x3C; V; ++j) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                // Skip if no path exists through the intermediate vertex\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                if (dist[i][k] == INF || dist[k][j] == INF)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                    continue;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                // Update the shortest distance\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Check for negative weight cycles\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; V; ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if (dist[i][i] &#x3C; 0) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            cout &#x3C;&#x3C; \"Graph contains a negative weight cycle.\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            return;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Print the shortest distances\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Shortest distances between every pair of vertices:\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for (int i = 0; i &#x3C; V; ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int j = 0; j &#x3C; V; ++j) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            if (dist[i][j] == INF)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                cout &#x3C;&#x3C; \"INF \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            else\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                cout &#x3C;&#x3C; dist[i][j] &#x3C;&#x3C; \" \";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        cout &#x3C;&#x3C; \"\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int V = 4; // Number of vertices\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Adjacency matrix representation of the graph\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;int>> graph = {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {0, 3, INF, 5},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {2, 0, INF, 4},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {INF, 1, 0, INF},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {INF, INF, 2, 0}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    };\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    floydWarshall(V, graph);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">Time Complexity: O(V^3)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">8. Prim's Algorithm (MST):\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;iostream>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;vector>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;queue>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;climits>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// A utility function to print the MST\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void printMST(const vector&#x3C;int>&#x26; parent, const vector&#x3C;vector&#x3C;int>>&#x26; graph) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">cout &#x3C;&#x3C; \"Edge\\tWeight\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">for (int i = 1; i &#x3C; graph.size(); ++i) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">cout &#x3C;&#x3C; parent[i] &#x3C;&#x3C; \" - \" &#x3C;&#x3C; i &#x3C;&#x3C; \"\\t\" &#x3C;&#x3C; graph[i]parent[i]] &#x3C;&#x3C; \"\\n\";\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Prim's Algorithm function\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">void primMST(int V, vector&#x3C;vector&#x3C;int>>&#x26; graph) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">// Priority queue to pick the minimum weight edge\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">priority_queue&#x3C;pair&#x3C;int, int>, vector&#x3C;pair&#x3C;int, int>>, greater&#x3C;pair&#x3C;int, int>>> pq;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;int> key(V, INT_MAX);   // Stores the minimum weight for each vertex\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;bool> inMST(V, false); // Keeps track of vertices included in MST\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;int> parent(V, -1);    // Stores the MST structure\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Start with the first vertex (arbitrary choice)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    key[0] = 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    pq.push({0, 0}); // {weight, vertex}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    while (!pq.empty()) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int u = pq.top().second;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        pq.pop();\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        // Include vertex `u` in MST\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        inMST[u] = true;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        // Explore neighbors of `u`\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for (int v = 0; v &#x3C; V; ++v) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            // If `v` is not in MST and there's an edge `u-v` with smaller weight\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            if (graph[u][v] &#x26;&#x26; !inMST[v] &#x26;&#x26; graph[u][v] &#x3C; key[v]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                key[v] = graph[u][v];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                pq.push({key[v], v});\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                parent[v] = u;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Print the MST\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    printMST(parent, graph);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int V = 5; // Number of vertices\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    // Adjacency matrix representation of the graph\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;vector&#x3C;int>> graph = {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {0, 2, 0, 6, 0},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {2, 0, 3, 8, 5},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {0, 3, 0, 0, 7},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {6, 8, 0, 0, 9},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        {0, 5, 7, 9, 0}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    };\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    primMST(V, graph);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">Time Complexity: O((V+E)logV)\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">9. Disjoint Set Data Structure (Union-Find):\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF9CAC;font-style:italic\">>\u003C/span>\u003Cspan style=\"color:#89DDFF;font-style:italic\"> Disjoint Set data structure also known as Union-Find data structure has 2 main operations - Union by Rank/Size and Find operation\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF9CAC;font-style:italic\">>\u003C/span>\u003Cspan style=\"color:#89DDFF;font-style:italic\"> 1. Union by Rank/Size is used to join the smaller set to the larger set\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF9CAC;font-style:italic\">>\u003C/span>\u003Cspan style=\"color:#89DDFF;font-style:italic\"> 2. Find(x) operation is used to find the parent root node of the x node, at starting each set comprises of a single element who is the parent of itself\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;bits/stdc++.h>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">class DisjointSet {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    vector&#x3C;int> parent, size;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    public:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    DisjointSet(int n) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        parent.resize(n+1);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        size.resize(n+1, 1);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        for(int i = 0; i &#x3C;= n; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            parent[i] = i;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int find(int node) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if(node == parent[node]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            return node;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        return parent[node] = find(parent[node]);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    void unionBySize(int u, int v) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int rootU = find(u);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int rootV = find(v);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if(rootU == rootV) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            return;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if(size[rootU] &#x3C; size[rootV]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            parent[rootU] = rootV;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            size[rootV] += size[rootU];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        } else {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            parent[rootV] = rootU;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            size[rootU] += size[rootV];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">};\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">DisjointSet ds(7);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">ds.unionBySize(1, 2);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">ds.unionBySize(2, 3);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">ds.unionBySize(4, 5);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">ds.unionBySize(6, 7);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">ds.unionBySize(5, 6);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">if(ds.find(3) == ds.find(7)) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">cout &#x3C;&#x3C; \"Same Component\" &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">} else {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">cout &#x3C;&#x3C; \"Different Component\" &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">ds.unionBySize(3, 7);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">if(ds.find(3) == ds.find(7)) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">cout &#x3C;&#x3C; \"Same Component\" &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">} else {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">cout &#x3C;&#x3C; \"Different Component\" &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">Time Complexity: The amortized time complexity for both find and unionBySize is O(Î±(n)), which is nearly constant time for all practical purposes.\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003Cspan style=\"color:#F07178;font-weight:bold\">10. Kruskal's Algorithm (MST):\u003C/span>\u003Cspan style=\"color:#89DDFF;font-weight:bold\">**\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#FF9CAC;font-style:italic\">>\u003C/span>\u003Cspan style=\"color:#89DDFF;font-style:italic\"> Algo for Kruskal's:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">    1. Sort the graph as per edges in ascending order\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">    2. Perform union operation on 2 disjoint sets if they have different parent\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">#include &#x3C;bits/stdc++.h>\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">using namespace std;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">bool compareEdges(const vector&#x3C;int>&#x26; a, const vector&#x3C;int>&#x26; b) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">return a[2] &#x3C; b[2];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">class DisjointSet {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">vector&#x3C;int> parent, size;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">public:\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">DisjointSet(int n) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">parent.resize(n+1);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">size.resize(n+1, 1);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">for(int i = 0; i &#x3C;= n; i++) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">parent[i] = i;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int findParent(int node) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if(node == parent[node])\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            return node;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        return parent[node] = findParent(parent[node]);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    void unionBySize(int u, int v) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int rootU = findParent(u);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int rootV = findParent(v);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if(rootU != rootV) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            if(size[rootU] &#x3C; size[rootV]) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                parent[rootU] = rootV;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                size[rootV] += size[rootU];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            } else {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                parent[rootV] = rootU;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">                size[rootU] += size[rootV];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">};\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int kruskalMST(int n, vector&#x3C;vector&#x3C;int>>&#x26; edges) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">sort(edges.begin(), edges.end(), compareEdges);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    DisjointSet ds(n);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    int mstWeight = 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    for(auto&#x26; edge : edges) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int u = edge[0];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int v = edge[1];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        int weight = edge[2];\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        if(ds.findParent(u) != ds.findParent(v)) {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            mstWeight += weight;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">            ds.unionBySize(u, v);\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">        }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    }\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return mstWeight;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int main() {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">int n = 5; // Number of vertices\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">vector&#x3C;vector&#x3C;int>> edges = {\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">{0, 1, 10},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">{0, 2, 6},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">{0, 3, 5},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">{1, 3, 15},\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">{2, 3, 4}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">};\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    cout &#x3C;&#x3C; \"Weight of MST is \" &#x3C;&#x3C; kruskalMST(n, edges) &#x3C;&#x3C; endl;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">    return 0;\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF90\">}\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#C3E88D\">```\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#EEFFFF\">Time Complexity: O(ElogE+EÎ±(V)). Since ð›¼ ( ð‘‰ ) Î±(V) is very small, this simplifies to ð‘‚ ( ð¸ log â¡ ð¸ ) O(ElogE).\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#89DDFF\">---\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\n\u003Cspan class=\"line\">\u003C/span>\u003C/code>\u003C/pre>",{"headings":77,"localImagePaths":78,"remoteImagePaths":79,"frontmatter":80,"imagePaths":83},[],[],[],{"title":64,"slug":61,"description":65,"tags":81,"added":82},[68,69,70],["Date","2025-10-18T07:37:17.295Z"],[]]